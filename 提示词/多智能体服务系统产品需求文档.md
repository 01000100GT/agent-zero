# 多智能体服务系统产品需求文档 (PRD)

**版本: 1.0**

**作者: AI 产品经理**

## 1. 引言

### 1.1. 项目愿景

构建一个以“文档即软件”为核心理念、由AI驱动的下一代代码生成与软件开发管理平台。本系统旨在通过结构化的自然语言输入，自动化地完成从需求理解、架构设计到代码实现的全过程，将软件开发提升至一个全新的抽象层次，极大地提高开发效率、降低沟通成本并保证工程质量。

### 1.2. 产品概述

本产品是一个基于分层多智能体协同架构的智能服务系统。它通过一个高性能的异步消息队列（h2A）驱动各个专用Agent（如主控Agent、交互Agent、知识处理Agent等）协同工作，将复杂的软件开发任务分解、调度并执行。系统集成了强大的AI编译器，能够将符合规范的自然语言文档直接编译为高质量、可维护的源代码，并通过严格的验证机制确保代码的准确性和健壮性。

### 1.3. 目标用户

- **软件开发团队**：希望通过AI技术提升开发效率、规范开发流程、降低项目维护成本的团队。
- **独立开发者**：寻求自动化工具以快速实现产品原型、验证商业想法的个人开发者。
- **项目经理与产品经理**：希望通过更直观、更精确的自然语言方式定义产品需求，并直接驱动开发过程的非技术背景人员。
- **AI研究人员**：对多智能体系统、AI代码生成、自然语言编程等领域感兴趣的研究者和工程师。

## 2. 核心功能与架构亮点

本系统的核心竞争力源于其创新的架构设计和一系列紧密集成的功能模块。以下将详细阐述关键功能点，并结合 `Open-Claude-Code` 的实现案例进行说明。

### 2.1. 分层多Agent协同架构

**功能描述:**
系统采用分层、多角色的Agent架构，将复杂的软件开发任务拆解给不同职能的Agent协同完成。这种设计提高了系统的模块化程度、可扩展性和鲁棒性。

- **nO (Orchestrator) 主控Agent**: 系统的“大脑”，负责接收用户总任务，进行任务分解、规划，并将子任务分发给其他Agent。它维护着整个任务的全局上下文和状态。
- **I2A (Interaction) 交互Agent**: 负责处理与用户的实时交互，如澄清需求、请求反馈等。
- **UH1 (User-Handler) 用户处理Agent**: 专注于理解和解析用户的输入，将其转换为结构化的内部表示。
- **KN5 (Knowledge) 知识处理Agent**: 负责知识的检索、管理和推理，为其他Agent提供决策支持。

**架构示例 (参考 `agent.md` 和 `agent-core.md`):**

系统的Agent类型由一个枚举 `AgentType` 来定义，确保类型安全和职责明确。

```typescript:src/types/agent.ts
// 定义Agent的类型，明确各自的职责划分
export enum AgentType {
  nO = 'nO',       // 主控Agent，负责任务编排与调度
  I2A = 'I2A',     // 交互Agent，处理用户交互
  UH1 = 'UH1',     // 用户处理Agent，解析用户输入
  KN5 = 'KN5',     // 知识处理Agent，管理知识与上下文
}
```

`nO`主控Agent的核心逻辑是一个事件驱动的循环，它不断从消息队列中获取任务，调用大语言模型进行思考和决策，然后调度工具或分派给其他Agent执行。

```typescript:src/core/agent-core.ts
// nO主Agent的核心循环函数（伪代码）
async function nO_main_loop(context: SystemContext): Promise<void> {
  console.log("nO主Agent循环启动，开始监听任务...");
  // 循环监听h2A消息队列中的新消息
  for await (const message of context.messageQueue) {
    console.debug(`nO接收到新消息: ${JSON.stringify(message)}`);
    // 1. 上下文压缩与准备
    const compressedContext = await context.knowledgeAgent.compress(message.content);
    
    // 2. 调用大语言模型进行决策
    const decision = await call_llm(compressedContext);
    console.debug(`LLM决策结果: ${JSON.stringify(decision)}`);

    // 3. 根据决策调度工具或Agent
    if (decision.tool_to_use) {
      await context.toolExecutor.execute(decision.tool_to_use, decision.tool_params);
    } else if (decision.delegate_to_agent) {
      await context.agentDispatcher.dispatch(decision.delegate_to_agent, message);
    }

    // 4. 状态更新与日志记录
    await context.stateManager.update(decision.new_state);
    console.log("nO主Agent完成一轮任务处理。");
  }
}
```

### 2.2. 高性能h2A异步消息队列

**功能描述:**
系统的心跳与命脉。h2A (Asynchronous Agent-to-Agent) 消息队列是一个专为多智能体系统设计的、基于双重缓冲机制的高性能异步消息总线。它确保了Agent之间的通信是非阻塞的，支持背压处理，并为系统的实时响应和高吞吐量提供了基础。

**架构示例 (参考 `src/core/message-queue.ts`):**

h2A的核心是 `MessageBuffer`，一个基于循环数组实现的环形缓冲区，它提供了高效的消息入队和出队操作，避免了传统队列在频繁操作下的内存碎片和性能开销。

```typescript:src/core/message-queue.ts
// h2A消息队列的核心：循环消息缓冲区
class MessageBuffer<T> {
  private buffer: (T | undefined)[];
  private head: number = 0;
  private tail: number = 0;
  private size: number = 0;

  constructor(private capacity: number) {
    this.buffer = new Array(capacity).fill(undefined);
    console.log(`初始化容量为 ${capacity} 的消息缓冲区。`);
  }

  // 入队操作：将消息添加到队尾
  enqueue(item: T): boolean {
    if (this.isFull()) {
      console.warn("消息缓冲区已满，无法入队。");
      return false;
    }
    this.buffer[this.tail] = item;
    this.tail = (this.tail + 1) % this.capacity;
    this.size++;
    console.debug(`消息入队成功，当前队列大小: ${this.size}`);
    return true;
  }

  // 出队操作：从队头移除消息
  dequeue(): T | undefined {
    if (this.isEmpty()) {
      console.log("消息缓冲区为空，无法出队。");
      return undefined;
    }
    const item = this.buffer[this.head];
    this.buffer[this.head] = undefined;
    this.head = (this.head + 1) % this.capacity;
    this.size--;
    console.debug("消息出队成功，当前队列大小: ${this.size}");
    return item;
  }

  isFull(): boolean {
    return this.size === this.capacity;
  }

  isEmpty(): boolean {
    return this.size === 0;
  }
}
```

### 2.3. 7层事件驱动架构

**功能描述:**
系统整体遵循一个严格的7层事件驱动架构，每一层都通过h2A消息队列进行解耦和通信。这种分层设计使得系统结构清晰，职责分明，易于维护和扩展。

**架构示例 (参考 `ARCHITECTURE.md`):**

根据 `ARCHITECTURE.md` 的描述，这7层分别是：

1.  **L1 - 用户接口层 (UI Layer)**: 负责接收用户输入，展示系统输出。
2.  **L2 - 任务解析层 (Task Parsing Layer)**: UH1 Agent所在层，负责解析用户意图。
3.  **L3 - 任务规划与调度层 (Task Planning & Scheduling Layer)**: nO Agent所在层，负责任务分解和调度。
4.  **L4 - 知识与上下文管理层 (Knowledge & Context Layer)**: KN5 Agent所在层，提供知识支持。
5.  **L5 - 工具执行层 (Tool Execution Layer)**: 负责执行具体的开发工具，如读写文件、执行命令等。
6.  **L6 - 模型调用层 (Model Invocation Layer)**: 封装对底层大语言模型的调用。
7.  **L7 - 基础设施层 (Infrastructure Layer)**: 提供消息队列、状态管理、日志等基础服务。

这种架构的实现依赖于统一的消息格式和h2A消息总线，确保事件可以在各层之间顺畅流动。

### 2.4. 自然语言编程与AI编译器

**功能描述:**
这是系统的核心理念——“文档即软件”。用户通过编写符合 `NATURAL_LANGUAGE_SPECS.md` 规范的结构化文档来描述需求，系统内置的AI编译器 (`AI_COMPILER_GUIDE.md`) 会将该文档解析、理解，并自动生成高质量的源代码。

**架构示例 (参考 `NATURAL_LANGUAGE_SPECS.md`):**

规范定义了一个标准的10章节文档结构，确保了需求描述的完备性。

```markdown
# [项目名称] - 自然语言编程规范文档

1.  **项目概述**
2.  **核心功能**
3.  **技术栈选型**
4.  **数据模型**
5.  **API接口设计**
6.  **用户界面 (UI) 设计**
7.  **非功能性需求 (性能、安全)**
8.  **部署架构**
9.  **测试计划**
10. **AI编译器指令** (例如: `// @AI:Generate(language="typescript", style="airbnb")`)
```

AI编译器会逐章解析这份文档，理解其语义，并根据第10章的指令生成最终代码。

### 2.5. 严格的9层代码编辑验证机制

**功能描述:**
为了确保AI生成的代码以及后续修改的质量，系统对所有文件编辑操作（尤其是 `Edit` 工具）实施了一个9层验证机制。这个机制从语法、类型、逻辑到安全性，对代码进行全方位的静态和动态检查。

**架构示例 (参考 `ARCHITECTURE.md`):**

```typescript
// 9层验证机制的接口定义（伪代码）
interface EditValidationLayers {
  validateSyntax(code: string): boolean;         // 1. 语法正确性
  validateTypes(code: string): boolean;          // 2. 类型一致性
  validateStyle(code: string): boolean;          // 3. 代码风格
  validateLogic(code: string): boolean;          // 4. 业务逻辑初步检查
  validateDependencies(code: string): boolean;   // 5. 依赖完整性
  validateSecurity(code: string): boolean;       // 6. 安全漏洞扫描
  validatePerformance(code: string): boolean;    // 7. 性能回归检查
  runUnitTests(code: string): boolean;           // 8. 单元测试
  runIntegrationTests(code: string): boolean;    // 9. 集成测试
}
```

### 2.6. 强制文件状态追踪

**功能描述:**
为了防止Agent在决策时使用过时的文件信息，系统强制要求在读取任何文件之前，必须先通过 `readFileState` 工具获取文件的最新状态（如最后修改时间、哈希值）。这确保了LLM的上下文与工作区的真实状态保持一致。

**架构示例 (参考 `ARCHITECTURE.md`):**

```typescript
// 强制文件状态追踪的伪代码流程
async function safeReadFile(filePath: string): Promise<string> {
  // 1. 获取文件当前状态
  const currentState = await readFileState(filePath);
  console.debug(`获取文件'${filePath}'的当前状态: ${JSON.stringify(currentState)}`);

  // 2. 从缓存或知识库中获取LLM已知的该文件状态
  const knownState = context.knowledgeAgent.getFileState(filePath);

  // 3. 比较状态，如果不同则必须重新读取
  if (!isStateEqual(currentState, knownState)) {
    console.log(`文件'${filePath}'状态已改变，强制重新读取。`);
    const content = await fileSystem.readFile(filePath);
    // 更新知识库中的文件内容和状态
    context.knowledgeAgent.updateFile(filePath, content, currentState);
    return content;
  } else {
    console.log(`文件'${filePath}'状态未变，使用缓存内容。`);
    return context.knowledgeAgent.getFileContent(filePath);
  }
}
```

## 3. 总结

本PRD详细描述了一个基于 `Open-Claude-Code` 逆向分析成果而设计的、先进的多智能体服务系统。它通过分层Agent架构、高性能消息队列、自然语言编程、严格的代码验证和状态管理机制，构建了一个高效、可靠、智能的软件开发平台。本文档旨在为后续的研发工作提供清晰、全面的指引。